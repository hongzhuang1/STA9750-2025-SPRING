---
title: "Does proximity to NYC impact Connecticut real estate pricing ?" 
---





shift + command + enter : run the current chunk of code
option + command + I : insert a new {r} chunk 




```{r setup, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
```

```{r,message=FALSE}
library(readr)
library(tidyverse)
library(stringr)
library(ggplot2)
library(ggmap) # requires Google API
library(tidygeocoder)
library(DT)
library(scales)
library(gt)
library(rvest)
library(astsa)
library(httr)
library(readxl) # Read excel files into R
library(scales) # Used for number formatting 
library(sf)      # Used for geo spatial data 
library(geosphere)  # Used for geo spatial data 
library(tmaptools)
library(tigris) 
library(tmap)
library(leaflet)
library(sp)
library(ggthemes)
```




# Does proximity to NYC impact Connecticut real estate pricing?

# Why it matters?
Employment Opportunity
Higher Pay in NYC 
Easy Accessibility to public transportation to finance hub 

Source: U.S. Bureau of Labor Statistics, Occupational Employment and Wage Statistics




```{r}
# State wage
state_wage <- read_excel("~/STA9750/STA9750-2025-SPRING/data/fp01/state_M2023_dl.xlsx")
# Metropolitan areas wage 
metropolitan_area_wage <- read_excel("~/STA9750/STA9750-2025-SPRING/data/fp01/MSA_M2023_dl.xlsx")
# Non-metropolitan area wage
nonmetropolitan_area_wage <- read_excel("~/STA9750/STA9750-2025-SPRING/data/fp01/BOS_M2023_dl.xlsx")
```

```{r}
# Define a function to extract wage for a specific area 
extract_wage <- function(area, data){
  region_wage <- data |>
    filter(AREA_TITLE == area) |>
    select(AREA_TITLE, OCC_TITLE, O_GROUP, TOT_EMP, H_MEAN, A_MEAN, H_MEDIAN, A_MEDIAN) |>
    mutate(
      TOT_EMP = as.numeric(TOT_EMP),
      H_MEAN = as.numeric(H_MEAN),
      A_MEAN = as.numeric(A_MEAN),
      H_MEDIAN = as.numeric(H_MEDIAN),
      A_MEDIAN = as.numeric(A_MEDIAN),
      OCC_TITLE = ifelse(O_GROUP == "major" & grepl("Occupations", OCC_TITLE), 
                         gsub("Occupations", "", OCC_TITLE), OCC_TITLE)
    ) |>
  as.data.frame()
  
  #Rename columns
  colnames(region_wage) <- sapply(colnames(region_wage), str_to_lower)
  
  # Create a new column to hold the occupation category 
  region_wage <- region_wage |> 
    mutate(major_occ_title = ifelse(o_group == "major", occ_title, NA)) |>
    fill(major_occ_title, .direction = "down")
  
  # Remove any hidden space
  region_wage <- region_wage |> mutate(major_occ_title = str_trim(major_occ_title)) 
  
  # Return region wage
  return(region_wage)
}
```

```{r}
# New York Metropolitan Area occupations and wage 
ny_metro_wage <- extract_wage("New York-Newark-Jersey City, NY-NJ-PA", metropolitan_area_wage)

# CT state wide occupations and wage 
ct_wage <- extract_wage("Connecticut", state_wage)

ct_n_ny_metro <- rbind(ct_wage, ny_metro_wage)
```

```{r}
ny_metro_occ_ctgy <- ny_metro_wage |> filter(o_group == "major")
ct_occ_ctgy <- ct_wage |> filter(o_group == "major")

tot_emp <- rbind(ct_occ_ctgy, ny_metro_occ_ctgy) 
tot_emp
```

```{r}
ggplot(tot_emp, aes(x = tot_emp, y = occ_title, fill = area_title)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "",                                       # NEED TO ADD A TITLE!!!!!
       x = "Total Individuals Employed",
       y = "Occupation Type",
       fill = "Region", 
       caption = "Source: Bureau of Labor Statistics (BLS)") +
  scale_x_continuous(labels = label_number(scale_cut = cut_short_scale())) +     # Convert 100000 -> 100K
  theme_minimal() +
  theme(
    axis.title.x = element_text(margin = margin(t = 10),)    # Adjust space above x-axis label
  )
```

```{r}
# Define a function to plot the wage for a specific occupation type 
plot_mean_wage <- function(occupation_category){
  category_wage <- ct_n_ny_metro |>
    filter(major_occ_title == occupation_category & o_group == "detailed")
  
  plot <- ggplot(category_wage, aes(x = a_mean, y = occ_title, fill = area_title)) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(title = "",
           x = "Annual Mean Wage",
           y = "Occupation Title",
           fill = "Region",
           caption = "Source: Bureau of Labor Statistics (BLS)"
           ) +
    scale_x_continuous(labels = label_number(scale_cut = cut_short_scale())) +
    theme_minimal()
  
  print(plot)
}
```

```{r}
plot_mean_wage("Computer and Mathematical")
```

```{r}
plot_mean_wage("Management")
```

```{r}
plot_mean_wage("Business and Financial Operations")
```





# Data Acquisition and Preparation: CT Real Estate Analysis




```{r}
ct_sales <- read.csv("~/STA9750/STA9750-2025-SPRING/data/fp01/Real_Estate_Sales_2001-2022_GL.csv")
```

```{r}
# Parcel data of Connecticut
state_parcel <- read.csv("~/Downloads/Connecticut_CAMA_and_Parcel_Layer_3895368049124948111.csv")

# This dataset adds more details to state parcel data 
state_parcel_details <- read.csv("~/Downloads/2024_Connecticut_Parcel_and_CAMA_Data.csv")
```

```{r}
town_code_lookup <- read.csv("~/Downloads/Connecticut_Towns_-_Crosswalk_with_Tax_Codes_and_FIPS_Codes_20250426.csv")
```

```{r}
# Format `ct_sales` column names 
colnames(ct_sales) <- tolower(gsub("\\.", "_", colnames(ct_sales)))
```

```{r}
# Format `state_parcel` column names
colnames(state_parcel) <- tolower(gsub("\\.", "_", colnames(state_parcel)))
```

```{r}
# Format `state_parcel_details` column names
colnames(state_parcel_details) <- tolower(gsub("\\.", "_", colnames(state_parcel_details)))
```

```{r}
# Format `town_codes_mapping` column names
colnames(town_code_lookup) <- tolower(gsub("\\.", "_", colnames(town_code_lookup)))
```

```{r}
# Map tax code in `state_parcel_details` to town name 
state_parcel_details <- state_parcel_details |>
  left_join(town_code_lookup, by = c("town_id" = "tax_code"))
```

```{r}
glimpse(state_parcel_details)
```






## Property Type Exploration




```{r}
# Commercial
ct_sales |>
filter(grepl("commericial|industrial|land|comm|office|business|leasing|vacan|
               |vacant|corporation|corp|inn|hotel|funeral|retail|farm|golf
               |university|religious|religious org|station|courtland|church
               |group home|group|campsite|developer|shop|parking lot|mobile home
               |rehab|warehouse|barn|storage|leasor|leasee|mobile home", 
               assessor_remarks, ignore.case = TRUE), nchar(property_type) == 0)

# Residential
ct_sales |>
  filter(grepl("boat|beach|locker|apts|apt|condo units|multi family|family|
               apartments|house|build home|residential|tenant", 
               assessor_remarks, ignore.case = TRUE), nchar(property_type) == 0)

```




### Residential 


### Commerical 

Industrial properties can vary significantly per business use case: 

Warehouse: 
https://www.sentrycommercial.com/killingly-warehouse-sells-for-48m-in-sale-leaseback-deal/
https://www.hartfordbusiness.com/article/cheshire-warehouse-sold-for-39m 





```{r}
ct_sales |>
  filter(property_type == "Industrial") |>
  arrange(desc(sale_amount))
```








# Data Cleaning 

- Identify wrong/incorrect/duplicate entries. Use anti_join to remove these records 
  from our dataset.

- Remove properties whose sale prices are not comparable to similar properties 
  due to foreclosure, private sale, change in property or other reasons based 
  on the information provided in `non_use_code` column.




```{r}
# Duplicates, incorrect property values, etc 
to_remove <- ct_sales |>
  mutate(
  concerning = case_when(
    str_detect(opm_remarks, regex("duplicate|incorrect|wrong|error|missing", ignore_case = TRUE)) ~ "Yes",
    TRUE ~ "No")
) |>
  filter(concerning == "Yes")

# ct_real_estate |>
#   mutate(
#   concerning = case_when(
#     str_detect(opm_remarks, regex("duplicate|incorrect|wrong|error|missing", ignore_case = TRUE)) ~ "Yes",
#     TRUE ~ "No"
#     )
# ) |>
#   filter(concerning == "Yes") |>
#   mutate(
#     duplicate_index = 
#       ifelse(str_detect(opm_remarks, "DUPLICATE ENTRY"), 
#              str_remove(str_extract(opm_remarks, "#\\d+"), "#"), NA)
#   ) |>
#   filter(! is.na(duplicate_index)) |>
#   select(serial_number, address, duplicate_index)
```

```{r}
# Use anti_join to remove these incorrect/duplicate from our dataset
ct_sales <- ct_sales |>
  anti_join(to_remove, by = c("serial_number", "address"))

# Remove properties with non_use_code 
ct_sales <- ct_sales |> filter(nchar(non_use_code) == 0)

# Remove transactions with `sale_amount` 0
ct_sales <- ct_sales |> filter(sale_amount > 2000)
```

```{r}
# county town webpage 
url <- "https://libguides.ctstatelibrary.org/cttowns"

# Extract the table 
ct_towns_counties <- read_html(url) |>
  html_table(fill = TRUE)

ct_towns_counties <- as.data.frame(ct_towns_counties)

# Set the first row as col names 
colnames(ct_towns_counties) <- ct_towns_counties[1, ]

# Remove the first row (now it's the header)
ct_towns_counties <- ct_towns_counties[-1, ]

# Reset row indices starts from 1
row.names(ct_towns_counties) <- NULL

# Left join to map `town` to county
ct_sales <- ct_sales |>
  left_join(ct_towns_counties, by = c("town" = "Town name")) |>
  select(-"Year Established", -"Parent Town", -"History of incorporation") |>
  rename(
    county = "County"
  )
```

```{r}
datatable(head(ct_sales, 10), options = 
            list(scrollX = TRUE, scrollY = 300, paging = TRUE))
```

```{r}
# # Select the desired columns 
# ct_sales <- ct_sales |>
#   select(
#     serial_number, list_year, date_recorded, town, county, address, assessed_value,
#     sale_amount, sales_ratio, property_type, residential_type, location
#   )
```






## Missing Values: `property_type`: look up property type based on land use code 

sales data with 784,135 




```{r}
ct_sales

# Properties with missing property type 
property_missing_type <- ct_sales |>
  filter(nchar(property_type) == 0)

property_w_type <- ct_sales |>
  filter(nchar(property_type) > 0)
```

```{r}
dim(property_missing_type)
```

```{r}
dim(property_w_type)
```

```{r}
# Find common properties in both categories 
common_properties <- property_missing_type |>
  select(address1) |>
  inner_join(property_w_type |> select(address1, property_type, residential_type), by = "address1") |>
  distinct(address1, .keep_all = TRUE)

# Updated `property_missing_type` by filling in the `property_type` and `residential_type` info 
property_missing_type <- property_missing_type |>
  left_join(common_properties, by = "address1") |>
  mutate(
    property_type.x = property_type.y,
    residential_type.x = residential_type.y
  ) |>
  select(-property_type.y, - residential_type.y) |>
  rename(
    property_type = property_type.x,
    residential_type = residential_type.x
  ) 

# Combine updated properties to the data frame `property_w_type`
property_w_type <- bind_rows(
  # 53,541
  property_missing_type |> filter(nchar(property_type) > 0),
  property_w_type
)

# New `property_missing_type`
property_missing_type <- property_missing_type |>
  filter(is.na(property_type))

```





### USE `state_parcel` 




```{r}
land_use_codes <- read.csv("~/Downloads/Connecticut Land Use Codes.csv")
colnames(land_use_codes) <- tolower(colnames(land_use_codes))

# Find code prefix for easy property type mapping
land_use_codes <- land_use_codes |>
  mutate(
    code_prefix = substr(code, 1, 3)
  )

# Vacant land use code 
vacant_land_codes <- land_use_codes |>
  filter(grepl("vac", description, ignore.case = TRUE)) |>
  select(code) |>
  pull()

# Map land use codes to property types
land_use_codes <- land_use_codes |>
  mutate(
    property_type = case_when(
      description == "null" ~ "Unknown",
      description == "Apartment Land" ~ "Apartment Land",
      code %in% vacant_land_codes ~ "Vacant Land",
      as.numeric(code_prefix) >= 100 & as.numeric(code_prefix) < 200 ~ "Residential",
      as.numeric(code_prefix) >= 200 & as.numeric(code_prefix) < 300 ~ "Commerical",
      as.numeric(code_prefix) >= 300 & as.numeric(code_prefix) < 400 ~ "Industrial",
      as.numeric(code_prefix) >= 400 & as.numeric(code_prefix) < 500 ~ "Public Utility",
      as.numeric(code_prefix) >= 600 & as.numeric(code_prefix) < 800 ~ "Agricultural",
      as.numeric(code_prefix) >= 800 & as.numeric(code_prefix) < 900 ~ "Apartments",
      TRUE ~ "Other"
    ),
    residential_type = case_when(
      property_type == "Residential" & grepl("res", description, ignore.case = TRUE) ~ "Residential",
      property_type == "Residential" & grepl("condo", description, ignore.case = TRUE) ~ "Condominium",
      property_type == "Residential" & grepl("sfr", description, ignore.case = TRUE) ~ "Single Family",
      property_type == "Residential" & grepl("2 fam", description, ignore.case = TRUE) ~ "Two Family",
      property_type == "Residential" ~ description,
      TRUE ~ ""
    )
  )
land_use_codes
```

```{r}
# Select distinct land use description for joining 
land_use_codes <- land_use_codes |>
  distinct(description, .keep_all = TRUE)

# Select the properties in `state_parcel` with land use description column 
state_parcel <- state_parcel |>
  filter(nchar(location) > 0) |>
  select(location, town_name, state_use_description) |>
  mutate(location_w_town = paste(location, town_name)) |>
  distinct(location_w_town, .keep_all = TRUE)

# Obtain property type and residential type for the properties in `state_parcel`
state_parcel <- state_parcel |>
  left_join(land_use_codes, by = c("state_use_description" = "description")) |>
  select(location_w_town, property_type, residential_type) |>
  distinct(location_w_town, .keep_all = TRUE)
  
# Left join `state_parcel`

# 15,167
property_missing_type |>
  left_join(state_parcel, by = c("address1" = "location_w_town")) |>
  filter(! is.na(property_type.y)) |>
  mutate(
    property_type.x = property_type.y,
    residential_type.x = residential_type.y
  ) |>
  rename(
    property_type = property_type.x,
    residential_type = residential_type.x
  ) |>
  select(-ends_with(".y"))

```






-----------------------------------

### USE `state_parcel_details` 




```{r}
not_found |>
  select(address) |>
  mutate(
    if_ending_w_digits = str_detect(address, "\\d+$")   # Ending with digit(s) more likely to be condo type
  ) |>
  filter(if_ending_w_digits == TRUE)
```

```{r}
str_detect("75 WASHINGTON AVE 3-204", "\\d+$") 
```

```{r}
state_parcel |>
  filter(location == "41-43 WILLARD ST") |>
  select(location, town_name)
```




examples: "41-43 WILLARD ST", "WILLARD ST"; 85 VISCOUNT DR U4A, VISCOUNT DR



```{r}
state_parcel_details |>
  filter(street_name == "MIX AVE") |>
  select(location, street_name, town_name)
```

```{r}
state_parcel_details |>
  filter(nchar(location) > 0) |>
  select(state_use, state_use_description) |>
  distinct() 
```

```{r}
state_parcel_details |>
  filter(nchar(location) > 0, nchar(state_use) > 0, nchar(state_use) < 3) |>
  select(location, town_name, state_use, state_use_description) |>
  mutate(
    address = paste(location, town_name),
    state_use_description = gsub("MDL.*", "", state_use_description),
    location_w_town = paste(location, town_name),
    property_type = case_when(
      grepl("res|residential", state_use_description, ignore.case = TRUE) ~ "Residential",
      grepl("ind|industrial", state_use_description, ignore.case = TRUE) ~ "Industrial",
      grepl("vac|vacant", state_use_description, ignore.case = TRUE) ~ "Vacant Land",
      grepl("commericial|com|retail|office|mixed|dealer|shop|store|space", 
            state_use_description, ignore.case = TRUE) ~ "Commericial",
      TRUE ~ "Other"
    )
  ) |>
  select(location_w_town, property_type) |>
  distinct(location_w_town, .keep_all = TRUE)
```

```{r, warning=FALSE}
# Select the columns for property type look up in `state_parcel_details` 
property_type_lookup <- state_parcel_details |>
  filter(nchar(location) > 0, nchar(state_use) >= 3) |>
  select(location, town_name, state_use_description, state_use) |>
  mutate(
    location_w_town = paste(location, town_name),
    state_use_prefix = substr(state_use, 1, 3),
    state_use_description = gsub("MDL.*", "", state_use_description)
  ) |>
  select(location_w_town, state_use_prefix, state_use_description) |>
  distinct(location_w_town, .keep_all = TRUE)

# Get property type based on `state_use_prefix`
property_type_lookup <- property_type_lookup |>
  mutate(
    property_type = case_when(
      grepl("vac", state_use_description, ignore.case = TRUE) ~ "Vacant Land",
      state_use_description == "null" ~ "Unknown",
      state_use_description == "Apartment Land" ~ "Apartment Land",
      as.numeric(state_use_prefix) >= 100 & as.numeric(state_use_prefix) < 200 ~ "Residential",
      as.numeric(state_use_prefix) >= 200 & as.numeric(state_use_prefix) < 300 ~ "Commerical",
      as.numeric(state_use_prefix) >= 300 & as.numeric(state_use_prefix) < 400 ~ "Industrial",
      as.numeric(state_use_prefix) >= 400 & as.numeric(state_use_prefix) < 500 ~ "Public Utility",
      as.numeric(state_use_prefix) >= 600 & as.numeric(state_use_prefix) < 800 ~ "Agricultural",
      as.numeric(state_use_prefix) >= 800 & as.numeric(state_use_prefix) < 900 ~ "Apartments",
      TRUE ~ "Other"
    ),
    residential_type = case_when(
      property_type == "Residential" & grepl("single fam|sfr", state_use_description, ignore.case = TRUE) ~ "Single Family",
      property_type == "Residential" & grepl("res", state_use_description, ignore.case = TRUE) ~ "Residential",
      property_type == "Residential" & grepl("condo", state_use_description, ignore.case = TRUE) ~ "Condominium",
      property_type == "Residential" & grepl("2 fam", state_use_description, ignore.case = TRUE) ~ "Two Family",
      property_type == "Residential" ~ state_use_description,
      TRUE ~ ""
    )
  )
```

```{r}
head(property_type_lookup, 10)
```




--------------------------------------------------




```{r}
# 224,385: 79,755 solved
property_missing_type |>
  left_join(property_type_lookup, by = c("address1" = "location_w_town")) |>
  filter(is.na(property_type.y)) |>
  select(address) |>
  distinct() |>
  mutate(
    if_ending_w_digits = str_detect(address, "\\d+$|#\\w+$|#")
  ) |>
  filter(if_ending_w_digits == TRUE)
  
```

```{r}
property_missing_type |>
  left_join(property_type_lookup, by = c("address1" = "location_w_town")) |>
  filter(is.na(property_type.y)) |>
  select(address) |>
  distinct() |>
  mutate(
    if_not_starting_w_digits = ! str_detect(address, "^\\d")
  ) |>
  filter(if_not_starting_w_digits == TRUE)
```

```{r}
to_solve <- property_missing_type |>
  left_join(property_type_lookup, by = c("address1" = "location_w_town")) |>
  filter(is.na(property_type.y)) |>
  select(address1) |>
  distinct()
```

```{r}
dim(to_solve)
```

```{r}
ct_sales |>
  filter(nchar(non_use_code) > 0, nchar(property_type) > 0) |>
  mutate(
    address1 = paste(address, town)
  )|>
  select(address1) |>
  distinct() |>
  inner_join(to_solve, by = "address1")
```






--------------------------------------












```{r}
# Commercial: key words
solved |>
  filter(grepl("lnd|land|devel|development|office|post off|restaurant|store|shop
               |retail|mob|mobile home|office|industrial|comm|commercial|cemetary
               |ind|park|gas|rtl|auto|car wash|facili|com|rest|clubs|non-profit", 
               state_use_description, ignore.case = TRUE))


# Residential: key words
solved |>
  filter(
  grepl("fam|family|res|residential|condo|res dwelling|multi|apt|sfr|apartments", 
               state_use_description, ignore.case = TRUE)
  )

solved |>
  mutate(
    property_type = case_when(
      grepl("fam|family|res|residential|condo|res dwelling|multi|apt|sfr|apartments", 
               state_use_description, ignore.case = TRUE) ~ "Residential",
      TRUE ~ "Non-residential"
    )
  )
```











After missing property type is handled, we can check again `opm_remarks` 
to decide 





```{r}
ct_sales |>
  select(opm_remarks) |>
  distinct()
```

```{r}
# Duplicate sales on same day
ct_sales |>
  filter(grepl("same day", opm_remarks, ignore.case = TRUE)) |>
  distinct(address, .keep_all = TRUE)    # Remove duplicate sales based on `address`
```






## To-do: Repeated Measures ANOVA




```{r}
model <- aov(sale_amount ~ county, data = ct_sales)
summary(model)
```

```{r}
plot(model)
```

```{r}
ct_sales |>
  filter(town == "Greenwich") |>
  arrange(desc(address))
```

```{r}
ct_sales |>
  select(address)
```






## To-do: The distribution of `sale_amount`




```{r}
# Select the properties without a property type
ct_sales |>
  mutate(len = nchar(property_type)) |> # number of characters in a string 
  filter(len == 0) 
```

```{r}
ct_sales |>
  filter(nchar(location) == 0 & sale_amount > 10000) |>
  select(sale_amount) |>
  summary()
```

```{r}
ct_sales |>
  filter(nchar(location) == 0 & county == "Fairfield") |>
  group_by(town) |>
  summarize(n = n())
```

```{r}
ct_sales |>
  filter(nchar(location) == 0 & county == "Fairfield" & town == "Norwalk") |>
  select(sale_amount) |>
  summary()
```

```{r}
ct_sales |>
  filter(nchar(location) > 0  & county == "Fairfield" & town == "Norwalk") |>
  select(sale_amount) |>
  summary()
```

```{r}
ct_sales |>
  filter(county == "Fairfield" & town == "Norwalk") |>
  select(sale_amount) |>
  summary()
```

```{r}
ct_sales |>
  filter(nchar(location) > 0 & sale_amount > 10000) |>
  select(sale_amount) |>
  summary()
```

```{r}
ct_sales |>
  filter(sale_amount > 10000) |>
  select(sale_amount) |>
  summary()
```




# Data Preprocessing 

## Download Connecticut County and Town Shape files for Mapping




```{r}
# FIPS code '09' for state 'Connecticut'
# ct_blocks <- blocks(state = "CT")

# Plots a blank base map
# tm_shape(ct_blocks) + tm_borders(alpha = 0.4)

# ct_counties <- counties(state = "Connecticut", year = 2020)

# tm_shape(ct_counties) + tm_borders(alpha = 0.4)
```

```{r}
# Read county shape file into R
counties <- st_read("~/downloads/tl_2020_us_county/tl_2020_us_county.shp") |>
  filter(STATEFP == "09")
View(counties)
```

```{r}
# Town shape file
ct_towns <- st_read("~/downloads/tl_2020_09_cousub/tl_2020_09_cousub.shp")

View(ct_towns)
```

```{r}
# https://r-tmap.github.io/tmap-book/visual-variables.html
tmap_mode("plot")

tm_shape(ct_counties) +
  tm_polygons(col = "NAME", palette = "set3") # Color the county polygons using a categorical color palette
```

```{r}
# ct_towns <- county_subdivisions(state = "Connecticut", year = 2020)
# # Tracts
# tracts_data <- tracts(state = "Connecticut", year = 2020)
```

```{r}
plot(st_geometry(ct_towns), col = "lemonchiffon2")
```

```{r}
sale_price_by_town <- ct_sales |>
  group_by(town) |>
  summarize(avg_price = mean(sale_amount)) |>          # Calculate the average pricing for each town in CT
  right_join(ct_towns, by = c("town" = "NAME")) |>     # Right join the spatial data of towns 
  st_as_sf()
```

```{r}
# remove some outliers with extremely high pricing by adding the condition: sale_amount < 5 mil
sale_price_by_town <- ct_sales |>
  filter(sale_amount < 5000000) |>
  group_by(town) |>
  summarize(avg_price = mean(sale_amount)) |>          # Calculate the average pricing for each town in CT
  right_join(ct_towns, by = c("town" = "NAME")) |>     # Right join the spatial data of towns 
  st_as_sf()

```

```{r}
View(sale_price_by_town)
```

```{r}
tmap_mode("view") # Set mode to interactive

tm_shape(sale_price_by_town) +
  tm_polygons("avg_price", palette = "YlOrRd" )  # other palette "YlOrRd", "YlGnBu" (yellow green blue)
```

```{r}
tmap_mode("plot") # Set mode to static

tm_shape(sale_price_by_town) +
  tm_polygons("avg_price", palette = "YlOrRd" )  # other palette "YlOrRd", "YlGnBu" (yellow green blue)
```

```{r}
ggplot(sale_price_by_town) +
  geom_sf(aes(fill = avg_price),
          lwd = 0.05,           # line width among towns 
          color = "white")    # use color black 
  # scale_fill_fermenter(
  #   name = "Mean House Price ($)",
  #   direction = 1,
  #   palette = "Blues") + 
  # labs(title = "Mean House Price ($) in (Connecticut) from 2001-2023") +
  # theme_map() +
  # theme(legend.position = "right",
  #       legend.title = element_text(face = "bold"),
  #       plot.title = element_text(size = 14,
  #                                 color = "black",
  #                                 face = "bold"))
```

```{r}

ggplot(sale_price_by_town) +
  geom_sf(aes(fill = avg_price),
          lwd = 0.1,           # line width among towns 
          color = "black") +    # use color black 
  scale_fill_fermenter(
    name = "Mean House Price ($)",
    direction = 1,
    palette = "YlOrRd") + 
  labs(title = "Mean House Price ($) in (Connecticut) from 2001-2023") +
  theme_map() +
  theme(legend.position = "right",
        legend.title = element_text(face = "bold"),
        plot.title = element_text(size = 20,
                                  color = "black",
                                  face = "bold"))
```

```{r}
price_points <- ct_sales |>
  filter(nchar(location) > 0) |>
  mutate(location = st_as_sfc(location, crs = 4269)) |>
  st_as_sf()
```

```{r}
View(price_points)
```

```{r}
one_family_price_points <- price_points |>
  filter(residential_type == "Single Family")

one_family_price_points
```

```{r}
one_family_price_pts <- ct_real_estate |>
  filter(residential_type == "Single Family") |>
  group_by(town) |>
  summarize(avg_price = mean(sale_amount)) |>
  left_join(ct_towns, by = c("town" = "NAME")) |>
  st_as_sf()
```

```{r}
tmap_mode("view")

tm_shape(ct_counties) + tm_borders(fill_alpha = 0.2) +
  tm_shape(one_family_price_pts) + tm_bubbles(size = "avg_price", scale = 1.5,col = "avg_price",
                                           palette = "Reds", fill.scale = tm_scale_intervals("quantitle"),
                                           fill.legend = "House Pricing ($)")
```

```{r}
tmap_mode("plot")

tm_shape(ct_counties) + tm_borders(alpha = 0.5) +
  tm_shape(ct_towns_w_prices) + tm_bubbles(size = "avg_price", scale = 1.5, col = "avg_price",
                                           palette = "Blues", style = "quantile",
                                           title.col = "House Prices ($)")
  
```

```{r}
one_family_fairfield <- price_points |>
  filter(county == "Fairfield", residential_type == "Single Family")

View(one_family_fairfield)
```

```{r}
tm_shape(one_family_fairfield) + tm_borders()
```

```{r}
tm_shape(one_family_fairfield) + tm_dots(col = "sale_amount", style = "quantitle", palette = "Reds")
```

```{r}
tm_shape(ct_towns) + tm_borders(col = "black")
```





## Define the metric of proximity to NYC: using Grand Central as anchor point  




```{r}
# Plot NYC Grand Central on map
locations <- data.frame(places = c("Greenwich, CT", "Grand Central Terminal, NYC"))

# Geocode addresses
lat_longs <- locations |> geocode(places, method = 'osm')

# Visualize using Leaflet
leaflet() |>
  addTiles(group = "OSM") |>
  addMarkers(
    data = lat_longs,
    lat =  ~ lat,
    lng =  ~ long,
    label = ~ places,
    labelOptions = labelOptions(noHide = TRUE, direction = 'auto')
  )
```




In this section, we first define the metric of proximity to NYC using 
Grand Central Station as the anchor point. Then, we calculate the distance from 
each property in `ct_sales` to this anchor.

To calculate the distance, we address the following issues:

1. Properties with missing geographic coordinates:
  - Use zip code information from `state_parcel_details` 
  - For the remaining cases, impute coordinates using town-level geometry data

2. Properties with incorrect geographic coordinates: 
  - Identify them using functions from the `sf` library
  - Correct them using distance calculated from town centroid geometry data 


## Calculate Distance to Grand Central Terminal 

### Calculate Distance to Grand Central based on given coordinates 




```{r}
# Create sf object for the properties with coordinates
ct_sales_sf <- ct_sales |> 
  filter(nchar(location) > 0) |>
  mutate(location = st_as_sfc(location, crs = st_crs(ct_towns))) |>     # crs = st_crs(ct_towns)
  st_as_sf()  

# Create Grand Central Terminal sf object
grand_central <- st_sfc(st_point(c(-73.977229, 40.752726)), 
                        crs = st_crs(ct_sales_sf)) |> st_sf()

grand_central <- st_transform(grand_central, crs = st_crs(ct_sales_sf)) 

# select the relevant columns for right_join with `ct_sales`
coord_dist_to_nyc <- ct_sales_sf |>
  mutate(
    dist_to_nyc_by_coord = 
      round(as.numeric(st_distance(location, grand_central)/1000), 2)) |> # Compute distance
  st_drop_geometry() |>
  select(address, town, dist_to_nyc_by_coord) |>
  distinct()
```

```{r}
# 
coord_dist_to_nyc <- coord_dist_to_nyc |>
  mutate(property_address = paste(address, town)) |>
  select(property_address, dist_to_nyc_by_coord) |>
  distinct(property_address, .keep_all = TRUE)

coord_dist_to_nyc 
```

```{r}
# Concatenate `address` and `town` as left_join variable 
ct_sales <- ct_sales |>
  mutate(address1 = paste(address, town))
```

```{r}
# Left join `ct_sales` by `address` and `town`
ct_sales <- ct_sales |>
  left_join(
    coord_dist_to_nyc, by = c("address1" = "property_address")
  )
```





### Calculate Distance to Grand Central based on Zip Code

#### Find Zip Code Information for Properties with Missing Coordinates




```{r}
# Read the nationwide ZCTA shapefile into R 
zcta <- st_read("~/Downloads/tl_2020_us_zcta520/tl_2020_us_zcta520.shp")

# Filter zip codes starting with "06" for Connecticut state
ct_zcta <- zcta |>
  filter(substr(ZCTA5CE20, 1, 2) == "06") 

View(ct_zcta)
```

```{r}
# Property zip code look up data frame provided by `state_parcel_details`
zip_code_lookup  <- state_parcel_details |>
  filter(nchar(property_zip) > 0) |>
  mutate(address = paste(location, town_name)) |>
  select(address, property_zip) |>
  distinct(address, .keep_all = TRUE)

# 784,135
# Bring in zip code information
ct_sales <- ct_sales |>
  left_join(zip_code_lookup, by = c("address1" = "address"))

# Clean zip code column
ct_sales <- ct_sales |>
  mutate(
    property_zip = sub("\\..*$", "", property_zip),
    zip_code_prefix = substr(property_zip, 1, 1),
    zip_code = case_when(
      zip_code_prefix == "0" ~ substr(property_zip, 1, 5),
      zip_code_prefix == "6" ~ paste0("0", substr(property_zip, 1, 4)),
      TRUE ~ ""
      )
    ) |>
  select(-property_zip, -zip_code_prefix)
```

```{r}
# Check detailed CRS information
st_crs(ct_zcta)$proj4string
st_crs(ct_towns)$proj4string

st_crs(ct_towns)
st_crs(ct_zcta)
```

```{r}
# Ensure INTPTLON20 and INTPTLAT20 are numeric
ct_zcta <- ct_zcta |>
  mutate(
    INTPTLON20 = as.numeric(INTPTLON20),
    INTPTLAT20 = as.numeric(INTPTLAT20),
    # Combine lon and lat into a list of coordinates
    coordinates = mapply(c, INTPTLON20, INTPTLAT20, SIMPLIFY = FALSE),
    # Convert combined coordinates into a POINT geometry
    coordinate = st_sfc(lapply(coordinates, st_point), crs = st_crs(ct_zcta))
  ) |>
  select(-coordinates)

# Distance to Grand Central NYC using point geometry of zip codes 
zip_centroid_dist_to_nyc <- ct_zcta |>
  mutate(
    dist_to_nyc = round(as.numeric(st_distance(coordinate, grand_central)/1000), 2)) |> # Compute distance 
  st_drop_geometry() |>
  select(ZCTA5CE20, dist_to_nyc) |>
  rename(
    "zip_code" = "ZCTA5CE20",
    "dist_to_nyc_by_zip_code" = "dist_to_nyc"
  ) |>
  distinct()

head(zip_centroid_dist_to_nyc, 10)
```

```{r}
# 784,153
ct_sales <- ct_sales |>
  left_join(zip_centroid_dist_to_nyc, by = "zip_code")
```




### Calculate Distance to Grand Central based on town geometry 




```{r}
ct_towns <- ct_towns |>
  mutate(
    INTPTLON = as.numeric(INTPTLON),
    INTPTLAT = as.numeric(INTPTLAT),
    # Combine lon and lat into a list of coordinates
    coordinates = mapply(c, INTPTLON, INTPTLAT, SIMPLIFY = FALSE),
    # Convert combined coordinates into a POINT geometry
    coordinate = st_sfc(lapply(coordinates, st_point), crs = st_crs(ct_towns))
  ) |>
  select(-coordinates)

# Compute distance 
town_centroid_dist_to_nyc  <- ct_towns |>
  mutate(
    dist_to_nyc_by_town = round(as.numeric(st_distance(coordinate, grand_central)/1000), 2)) |>
  st_drop_geometry() |> 
  select(GEOID, NAME, dist_to_nyc_by_town) |> 
  rename(
    fips_code = "GEOID",
    town_name = "NAME"
  )

# Ensure town names are correct
town_dist_to_nyc <- town_code_lookup |>
  mutate(
    fips_code = as.character(fips_code),
    fips_code = paste0("0", fips_code)
    ) |>
  left_join(town_centroid_dist_to_nyc, "fips_code") |>
  rename(
    town = town_name.x,         
    town_name = town_name.y     # Town names from ct_town shapefile 
  ) |>
  select(-tax_code)
```

```{r}
ct_sales <- ct_sales |>
  left_join(town_dist_to_nyc, "town")
```

```{r}
ct_sales |>
  select(-fips_code, -town_name)
```





### Identify incorrect mapping of geo coordinate and property address




```{r}
ct_sales |>
  select(list_year, address, town, county, address1, dist_to_nyc_by_coord, 
         dist_to_nyc_by_zip_code, dist_to_nyc_by_town) |>
  mutate(
    diff = abs(dist_to_nyc_by_town - dist_to_nyc_by_coord)
  ) |>
  arrange(desc(diff)) |>
  filter(diff > 6) 
```

```{r}
ct_sales |>
  filter(address1 == "8 LAMBERT CMN Wilton")
```

```{r}
as.numeric(st_distance(st_sfc(st_point(c(-72.07312, 41.5585)), crs = st_crs(ct_towns)), grand_central))/1000
```





### Create Distance Bands



### Identify properties with wrong location: Approach 2

For now, let's focus on properties with valid location values.




```{r}
# ct_sales <- ct_sales |>
#   filter(nchar(location) > 0)    # Properties with valid coordinates
```

```{r}
ct_sales_sf <- ct_sales |>  
  filter(nchar(location) > 0) |>  # Properties with valid coordinates
  mutate(location = st_as_sfc(location, crs = st_crs(ct_towns))) |>      # crs = st_crs(ct_towns)
  st_as_sf()          # convert to sf object

# sf object
ct_sales_sf <- st_transform(ct_sales_sf, st_crs(ct_towns))

# By default, st_join() performs a left join
ct_sales_sf <- st_join(ct_sales_sf, ct_towns, join = st_intersects)    # st_intersects, st_contains both works

ct_sales_sf <- ct_sales_sf |> filter(town == NAME)
```

```{r}
View(ct_sales_sf)
```





#### To remove or we can solve it by finding the correct coordinates for these properties 




```{r}
# To remove these points with incorrect coordinates when calculating distance 
to_remove <- to_check_sf |>
  filter(is.na(NAMELSAD)) |> # any points don't fall within their corresponding town polygons have a NA value in "NAME" 
  View()
```

```{r}
# To remove: incorrect town and location mapping; some are due to town name discrepancies
to_check_sf |>
  filter(! is.na(NAME)) |>
  mutate(
    if_incorrect_coords = ifelse(str_detect(NAMELSAD, town), 1, 0)        # 1 correct coords;  0: wrong coords
  ) |>
  filter(if_incorrect_coords == 0) |>
  select(town, county, NAMELSAD) |>
  View()
```

```{r}
# create distance bands
ct_sales_sf <- ct_sales_sf |>
  mutate(
    dist_band = case_when(
      dist_to_nyc < 45 ~ " < 45",
      dist_to_nyc >= 45 & dist_to_nyc < 90 ~ "[45, 90) ",
      dist_to_nyc >= 90 & dist_to_nyc < 135 ~ "[90, 135)",
      dist_to_nyc >= 135 & dist_to_nyc < 180 ~ "[135, 180)",
      dist_to_nyc >= 180 & dist_to_nyc < 225 ~ "[180, 225)",
      TRUE ~ ">= 225"
    )
  )
```

```{r}
ct_sales_w_dist_bands <- ct_sales_sf |>
  st_drop_geometry(ct_sales_sf)

# Remove some columns 
ct_sales_w_dist_bands <- ct_sales_w_dist_bands[, -c(17:34)]
```

```{r}
lm(sale_amount ~ dist_to_nyc, data = ct_sales_w_dist_bands)
```

```{r}
lm(sale_amount ~ poly(dist_to_nyc, 2), data = ct_sales_w_dist_bands)
```

```{r}
ct_sales_w_dist_bands |>
  select(sale_amount) |>
  summary()
```

```{r}
ct_sales_w_dist_bands |>
  filter(sale_amount > 390000000)
```

```{r}
ct_sales |>
  filter(property_type == "Apartments") |>
  select(sale_amount) |>
  summary()
```




Below are more like apartment community 



```{r}
ct_sales |>
  filter(property_type == "Apartments" & sale_amount > 10000000) |>
  select(county) |>
  distinct()
```

```{r}
ct_sales |>
  filter(property_type == "Apartments" & sale_amount < 10000000)
  
```

```{r}
ct_sales |>
  filter(grepl("enterprise zone", assessor_remarks, ignore.case = TRUE)) |>
  select(address, sale_amount, property_type, residential_type, assessor_remarks)
```

```{r}
# ct_sales_sf |>
#   filter(sale_amount < 3000000 & residential_type == "Single Family")
```

```{r}
sale_price_by_distance <- ct_sales_sf |>
  filter(sale_amount < 3000000) |>
  group_by(dist_band) |>
  summarize(avg_price = mean(sale_amount)) |>
  arrange(desc(avg_price))

sale_price_by_distance
```

```{r}
ggplot(sale_price_by_distance, aes(x = reorder(dist_band, -avg_price), 
                                   y = avg_price, fill = avg_price)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  labs(x = "Distance Band", y = "Mean Pricing in Dollars ($)", 
       title = "Average Real Estate Sale Price by Distance") +
  theme(axis.text.x = element_text(angle = 0, hjust = 1))
```

```{r}
ggplot(sale_price_by_distance, aes(x = reorder(dist_band, -avg_price), y = avg_price, fill = avg_price)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = scales:: dollar(avg_price)),
            vjust= -0.25, size = 3, color = "black") +
  scale_fill_gradientn(colors = c("#FFFACD", "#FFD700", "#FFA500"),
                       labels = scales:: label_comma()) +       # formats the legend labels by adding comma as separator
  scale_y_continuous(labels = label_comma()) +
  theme_minimal() +
  labs(x = "Distance Band", y = "Mean Pricing in Dollars ($)", 
       title = "Average Real Estate Sale Price by Distance") +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5),
        plot.title = element_text(hjust = 0.5, face = "bold"),
        axis.title.x = element_text(margin = margin(t = 10)),
        axis.title.y = element_text(margin = margin(r = 10))
        )
```





## Create Different Distanct Bands (km)




```{r}
# Different Distance Bands (km)
ct_real_estate |>
  filter(dist > 0 & dist < 40)
```

```{r}
ct_real_estate |>
  filter(dist >= 40 & dist < 50) |>
  select(town, county) |>
  distinct()
```

```{r}
ct_real_estate |>
  filter(dist >= 40 & dist < 50, county == "Tolland")
```

```{r}
to_check_sf |>
  filter(town == "Stafford", address == "36 Grant Ave")
```

```{r}
ct_towns |>
  filter(NAME == "Stafford")
  
```

```{r}
ct_real_estate |>
  filter(dist >= 40 & dist < 50) |>
  filter(town == "Killingly", county == "Windham")
  
```






## Metro North Stops




```{r}
stops <- read.delim("~/STA9750/STA9750-2025-SPRING/data/fp01/gtfsmnr/stops.txt", 
                    header = TRUE, sep = ",", stringsAsFactors = FALSE)
```

```{r}
stops
```

```{r}
stops <- stops |>
  select(stop_name, stop_lat, stop_lon, stop_url)

stops
```





## Repeated Measures: Compare Appreciation Values Across These Distance Bands

Find the properties with prior sale in the 2001-22 and see how the values changed
in each distance band; we are expecting to see properties that close to NYC has
appreciated more than those in further away. 

If possible, analyze if renovations/improved house conditions impact the pricing?


## Compare real estate pricing





```{r}
ct_real_estate |>
  filter(town %in% c("Stamford", "Hartford"), residential_type == "Single Family") |>
  group_by(list_year, town) |>
  summarize(avg_price = mean(sale_amount)) |>
  pivot_wider(names_from = town, values_from = avg_price) |>
  mutate(
    multiple = round(`Stamford`/`Hartford`,0)
  )
  
```





the average single family property pricing in north haven, new haven county 
represents the mean, its proximity to major highways and new haven Amtrak station.




```{r}
ct_real_estate |>
  filter(county == "New Haven", residential_type == "Two Family") |>
  group_by(town) |>
  summarize(avg_price = mean(sale_amount)) |>
  arrange(desc(avg_price))
  
```

```{r}
ct_real_estate |>
  filter(county %in% c("Middlesex", "New London") , residential_type == "Condo", nchar(location) > 0) |>
  group_by(list_year, county) |>
  summarize(avg_price = mean(sale_amount)) |>
  pivot_wider(names_from = county, values_from = avg_price) 
```

```{r}
ct_real_estate |>
  filter(county == "Middlesex", residential_type == "Condo", nchar(location) > 0) |>
  arrange(desc(sale_amount))

  
```





two towns in New Haven county with close single family property pricing.

New Haven, West Haven both are stops on New Haven Lines. 




```{r}
ct_real_estate |>
  filter(town %in% c("New Haven", "Milford"), residential_type == "Single Family") |>
  group_by(list_year, town) |>
  summarize(avg_price = mean(sale_amount)) |>
  pivot_wider(names_from = town, values_from = avg_price) |>
  mutate(
    diff_pct = (`New Haven` - `Milford`)/`New Haven`
  )
```

```{r}
ct_real_estate |>
  filter(town %in% c("Westport", "Milford"), residential_type == "Single Family") |>
  group_by(list_year, town) |>
  summarize(avg_price = mean(sale_amount)) |>
  pivot_wider(names_from = town, values_from = avg_price) |>
  mutate(
    diff_pct = (`Westport` - `Milford`)/`Westport`
  )
```

```{r}
ct_real_estate |>
  filter(county %in% c("New Haven", "Hartford"), residential_type == "Single Family", nchar(location) > 0) |>

```

```{r}
ct_real_estate |>
  filter(town %in% c("East Haven", "West Haven"), residential_type == "Single Family") |>
  group_by(list_year, town) |>
  summarize(avg_price = mean(sale_amount)) |>
  pivot_wider(names_from = town, values_from = avg_price)
```




## Which county has the most highest average single family pricing in the past 20 years? 




```{r}
ct_real_estate |>
  filter(residential_type == "Single Family") |>
  group_by(list_year, town, county) |>
  summarize(avg_price = mean(sale_amount)) |>
  group_by(list_year) |>
  slice_max(avg_price, n = 1) 
```

```{r}
ct_real_estate |>
  filter(town == "Willington", list_year == 2020, residential_type == "Single Family") |>
  select(sale_amount) |>
  summary()
```



The sale amount 318790019	 is a wrong value; need to remove 



```{r}
ct_real_estate |>
  filter(town == "Willington", list_year == 2020, residential_type == "Single Family") |>
  arrange(desc(sale_amount)) 
```

```{r}
ct_real_estate |>
  filter(county == "Fairfield", residential_type == "Single Family") |>
  group_by(town) |>
  summarize(avg_price = mean(sale_amount)) |>
  arrange(desc(avg_price))
```




Metro-North Railroad: New Canaan Branch

New Canaan (Fairfield) -> Talmadge Hill -> Springdale -> Glenbrook -> Stamford (Fairfield) -> Harlem 125th -> NYC Grand Central


Metro-North Railroad: Danbury Branch

Danbury -> Bethel -> Redding -> Branchville -> Cannondale -> Wilton -> Merritt 7 -> South Norwalk -> Harlem 125th -> Grand Central


Metro-North Railroad: Waterbury Branch

Waterbury -> Naugatuck -> 
















```{r}
ct_real_estate |>
  filter(county == "New Haven", residential_type == "Single Family") |>
  group_by(town) |>
  summarize(avg_price = mean(sale_amount)) |>
  summary()
  
```



Fairfield, stamford, 



```{r}
ct_real_estate |>
  filter(county == "Fairfield", residential_type == "Single Family") |>
  group_by(town) |>
  summarize(avg_price = mean(sale_amount)) |>
  arrange(desc(avg_price))
  
```




fairfield




```{r}
ct_real_estate |>
  filter(county == "Fairfield", residential_type == "Condo") |>
  group_by(town) |>
  summarize(avg_price = mean(sale_amount)) |>
  arrange(desc(avg_price))
```

```{r}
ct_real_estate |>
  filter(county == "Fairfield", residential_type == "Condo") |>
  group_by(town) |>
  summarize(avg_price = mean(sale_amount)) |>
  summary()
```





mode: 

Buses: CTtansit is the largest bus operation in CT.
Rail: New Haven Line, Shore Line East, Hartford Line and Amtrak

- New Haven Line (Metro North) : linking CT and NYC
  Links cities and towns from New Haven **Union Station** in New Haven to Grand
  Central Terminal in NYC
  
  New Haven Union Station is your link to Shore Line East, Amtrak Acela and Amtrak
  Northeast Regional rail services. 



Union Station in New Haven is a major transportation hub for the region, serving 
both commuter rail and Amtrak services.

It serves as the terminal for trains coming from various locations in CT




Stamford is a major stop on New Haven Line (Metro North) and it offers connections
to Danbury Branch of the New Haven Line 

Both are located in Fairfield County in CT. 

Stamford has easy access to Metro North which connects CT to Grand Central Terminal.

Danbury branch connecting to New Haven Line 




```{r}
ct_real_estate |>
  filter(residential_type == "Single Family", town %in% c("Stamford", "Danbury")) |>
  group_by(list_year, town) |>
  summarize(avg_price = mean(sale_amount)) |>
  pivot_wider(names_from = town, values_from = avg_price) |>
  filter(! is.na(Danbury) & ! is.na(Stamford))
```





New Canaan branch connecting to New Haven Line but New Canaan has an overall 
property price than in Stamford.




```{r}
ct_real_estate |>
  filter(residential_type == "Single Family", town %in% c("Stamford", "New Canaan")) |>
  group_by(list_year, town) |>
  summarize(avg_price = mean(sale_amount)) |>
  pivot_wider(names_from = town, values_from = avg_price) 
```




Which town has the highest average single family property price in CT

Greenwich is the closest town in CT to New York City.  




```{r}
ct_real_estate |>
  filter(residential_type == "Single Family") |>
  group_by(town) |>
  summarize(avg_price = mean(sale_amount)) |>
  arrange(desc(avg_price)) |>
  left_join(ct_real_estate, by = "town") |>
  select(town, county, avg_price) |>
  distinct()
```

```{r}
ct_real_estate |>
  filter(county == "New Haven", residential_type == "Single Family") |>
  group_by(town) |>
  summarize(avg_price = mean(sale_amount)) |>
  arrange(desc(avg_price))
```

```{r}

```






















--------------------------------------------------------------------------------



 






```{r}
total_dollar_value_by_county
```

```{r}
ggplot(total_dollar_value_by_county, aes(x = total_dollar_value, 
                                         y = reorder(county, total_dollar_value))) +
  geom_bar(stat = "identity", fill = "steelblue") +
  scale_x_continuous(labels = comma) +
  labs(title = "Total Real Estate Dollar Value by County 2001-2023 in Connecticut", 
       x = "Total Dollar Value", y = "County") +
  theme_minimal() +
  theme(panel.grid = element_blank(),
        axis.title.x = element_text(margin = margin(t = 10)), # Adjust the distance of x-axis title from axis
        axis.title.y = element_text(margin = margin(r = 10))) +
  geom_text(aes(label = scales::comma(total_dollar_value)),
            color = "white",
            hjust = 1,
            size = 4)
```

```{r}
ct_real_estate_sales |>
  select(property_type) |>
  distinct()
```

```{r}
ct_real_estate_sales |>
  filter(is.na(property_type))
```









## GDP Data


Obtain real GDP data from FRED for Connecticut at the county level.




```{r, message=FALSE, warning=FALSE}

# Create an empty final data frame with the desired column structure
GDP <- data.frame(
  Name = character(),
  Period = integer(),
  Value = numeric(),
  "Preceding_Period" = numeric(),
  "Year_Ago_from_Period" = numeric(),
  County = character()
  )

# Data source
fred_url <- "https://fred.stlouisfed.org/release/tables?rid=397&eid=1071761&od=Year-01-01#"

# Scrape GDP data between 2001 and 2015
for (year in 2001:2015){
  current_url <- gsub("Year", year, fred_url)
  
  # Read the webpage
  fred_webpage <- read_html(current_url)
  
  #Extract the table 
  GDP_data <- fred_webpage |> html_table(fill = TRUE)
  
  GDP_data <- as.data.frame(GDP_data)
  
  # Set the first row as header 
  colnames(GDP_data) <- GDP_data[1, ]
  
  GDP_data <- GDP_data[-1, ]
  
  GDP_data <- GDP_data[, -c(1,2)]
  
  row.names(GDP_data) <- NULL
  
  GDP_data <- GDP_data |>
    rename("Preceding_Period" = `Preceding\n          Period`,
           "Year_Ago_from_Period" = `Year Ago\n          from Period`)
  
  GDP_data <- GDP_data |>
    mutate(
      Period = as.integer(Period),
      Value = as.numeric(gsub(",", "", Value)),
      Preceding_Period = as.numeric(gsub(",", "", Preceding_Period)),
      Year_Ago_from_Period = as.numeric(gsub(",", "", Year_Ago_from_Period)),
      County = ifelse(lead(Name) == "All Industries", Name, NA)
      ) |>
    fill(County, .direction = "down")
  
  # Consolidate GDP data
  GDP <- bind_rows(GDP, GDP_data)
}

```

```{r, message=FALSE, warning=FALSE}
# Obtain real GDP for the years between 2016 and 2023
fred_url <- "https://fred.stlouisfed.org/release/tables?rid=397&eid=1071761&od=Year-01-01#"

for (year in 2016:2023){
  current_url <- gsub("Year", year, fred_url)
  
  fred_webpage <- read_html(current_url)

  # Extract the table 
  GDP_data <- fred_webpage |> html_table(fill = TRUE)

  GDP_data <- as.data.frame(GDP_data)
  
  # Set the first row as header
  colnames(GDP_data) <- GDP_data[1, ]
  
  GDP_data <- GDP_data[-1, ]
  
  GDP_data <- GDP_data[, -c(1,2)]
  
  row.names(GDP_data) <- NULL
  
  GDP_data <- GDP_data |>
    mutate(
      Period = year,
      County = ifelse(lead(Name) == "All Industries", Name, NA)
      ) |>
    fill(County, .direction = "down") 
  
  GDP_data <- GDP_data |>
    rename(
      Value = colnames(GDP_data)[2],  # Rename the second column to 'Value'
      "Preceding_Period" = `Preceding\n          Period`,
      "Year_Ago_from_Period" = `Year Ago\n          from Period`
    )
  
  GDP_data <- GDP_data[, c(1, 2, ncol(GDP_data), 3:(ncol(GDP_data)-1))]   # Rearrange the column order
  
  GDP_data <- GDP_data |>
    mutate(
      Value = as.numeric(gsub(",", "", Value)),
      Preceding_Period = as.numeric(gsub(",", "", Preceding_Period)),
      Year_Ago_from_Period = as.numeric(gsub(",", "", Year_Ago_from_Period))
    )
  
  GDP <- bind_rows(GDP, GDP_data) 
}
```

```{r}
GDP <- GDP[ !grepl("County",GDP$Name), ]
# Reset row indices from 1
row.names(GDP) <- NULL

GDP <- GDP |>
  select(-"Year_Ago_from_Period") |> # Remove the duplicate column
  rename(
    GDP_Component = Name
  ) |>
  mutate(
    Value = case_when(
      is.na(Value) ~ 0,
      TRUE ~ Value
    ),
    Preceding_Period = case_when(
      is.na(Preceding_Period) ~ 0,
      TRUE ~ Preceding_Period
    )
  ) |>
  fill(Period, .direction = "down")

# Rearrange the column order 
GDP <- GDP[c("Period", "County", "GDP_Component", "Value", "Preceding_Period")]
```

```{r}
GDP <- GDP |>
  mutate(
    Value = Value * 1000,
    Preceding_Period = Preceding_Period * 1000
  )
```

```{r}
# View(GDP)
```




Let's look at the total real estate transactions amount in the county: 
"Fairfield".




```{r}
fairfield_sales <- ct_real_estate_sales |>
  filter(county == "Fairfield") |>
  group_by(year_recorded) |>
  summarize(total_transactions = sum(sale_amount))
```

```{r}
fairfield_gdp <- GDP |>
  filter(County == "Fairfield County", GDP_Component == "All Industries") |>
  group_by(Period) |>
  summarize(real_GDP = sum(Value)) |>
  select(Period, real_GDP) |>
  mutate(
    Period = as.character(Period)
  )
```

```{r}
fairfield <- fairfield_gdp |>
  left_join(fairfield_sales, by = c("Period" = "year_recorded"))
```

```{r}
fairfield 
```

```{r, message=FALSE}
ggplot(fairfield, aes(x = real_GDP, y = total_transactions)) +
  geom_point(alpha = 0.5, size = 2) +
  scale_x_continuous(labels = comma) +        # Format the values with thousands' separator
  scale_y_continuous(labels = comma) + 
  labs(title = "GDP vs. Real Estate Transactions",
       x = "Real Gross Domestic Product",
       y = "Real Estate Transactions") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
par(mfrow = c(2,1))
plot(fairfield_gdp, type = "o", ylab = "Real GDP", main = "Fairfield Real GDP 2001-2023" )
plot(fairfield_sales, type = "o", ylab = "Transactions", main = "Fairfield Real Estate Sales 2001-2023" )
```

```{r}
par(mfrow = c(1,2))
plot.ts(fairfield_gdp)
plot.ts(fairfield_sales)
```

